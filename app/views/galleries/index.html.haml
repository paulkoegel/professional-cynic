%h1 Galleries

%img#aaa{src: ''}

- @galleries.each do |gallery|
  = link_to gallery.title, gallery_path(gallery)
  %br

:css
  #byte_content {
    margin: 5px 0;
    max-height: 100px;
    overflow-y: auto;
    overflow-x: hidden;
  }
  #byte_range { margin-top: 5px; }
%input#files{name: 'file', type: 'file', multiple: 'multiple'}/
Read bytes:
%span.readBytesButtons
  %button{"data-endbyte" => "4", "data-startbyte" => "0"} 1-5
  %button{"data-endbyte" => "14", "data-startbyte" => "5"} 6-15
  %button{"data-endbyte" => "7", "data-startbyte" => "6"} 7-8
  %button entire file
#byte_range
%br/
#byte_content
%br/
#crypto_sha256
-#%script{:src => "http://crypto-js.googlecode.com/svn/tags/3.0.2/build/rollups/sha256.js"}
-#%script{:src => "http://crypto-js.googlecode.com/svn/tags/3.0.2/build/components/enc-base64-min.js"}
:javascript
  var sha256;

  function readBlob(opt_startByte, opt_stopByte) {

    var files = document.getElementById('files').files;
    if (!files.length) {
      alert('Please select a file!');
      return;
    }

    var file = files[0];
    var start = parseInt(opt_startByte) || 0;
    var stop = parseInt(opt_stopByte) || file.size - 1;

    var reader = new FileReader();

    // If we use onloadend, we need to check the readyState.
    reader.onloadend = function(evt) {
      if (evt.target.readyState == FileReader.DONE) { // DONE == 2
        document.getElementById('byte_content').textContent = evt.target.result;
        document.getElementById('byte_range').textContent = 
            ['Read bytes: ', start + 1, ' - ', stop + 1,
             ' of ', file.size, ' byte file'].join('');

        //**UPDATED SOLUTION: Since its binary data, the message needs to be converted from string to bytes using Latin1**
            sha256.update(CryptoJS.enc.Latin1.parse(evt.target.result));

        var hash = sha256.finalize();

        document.getElementById('crypto_sha256').textContent = ['SHA-256: ', hash].join('');
      }
    };

    var blob = file.slice(start, stop + 1);
    reader.readAsBinaryString(blob);
  }

  document.querySelector('.readBytesButtons').addEventListener('click', function(evt) {
    if (evt.target.tagName.toLowerCase() == 'button') {
      var startByte = evt.target.getAttribute('data-startbyte');
      var endByte = evt.target.getAttribute('data-endbyte');

      sha256 = CryptoJS.algo.SHA256.create();

      readBlob(startByte, endByte);
    }
  }, false);

  $('input#files').change(function(e) {
      var target = e.originalEvent.srcElement || e.originalEvent.target;

      console.log(target.files.length);
      for (var i = 0; i < target.files.length; i++) {
        (function(i) {
          console.log(i);
          console.log(target);
          console.log(target.files);
          var file = target.files[i];
          console.log(file);
          var img = document.createElement("img");
          $(img).appendTo('.l-content-container');
          var reader = new FileReader();
          reader.onloadend = function() {
             img.src = reader.result;
          }
          reader.readAsDataURL(file);
          //$("input").after(img);
          console.log($(img));
          //$('<p>Test</p>').appendTo('.l-content-container');
          
        })(i);
      }
  });
